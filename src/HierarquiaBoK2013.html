<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estrutura Hier√°rquica</title>
    <style>
        ul {
            list-style: none;
            padding-left: 20px;
        }
        li {
            cursor: pointer;
        }
        input[type="text"] {
            width: 30%;
            padding: 5px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <input type="text" id="search" placeholder="Pesquisar conhecimento">
    <ul id="treeview">
<li>Algorithms and Complexity </li><ul><li>Basic Analysis</li><ul><li>Analysis of iterative and recursive algorithms</li><li>Asymptotic analysis of upper and expected complexity bounds</li><li>Big notation: formal definition</li><li>Big notation: use</li><li>Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential</li><li>Differences among best, expected, and worst case behaviors of an algorithm</li><li>Empirical measurements of performance</li><li>Little o, big omega and big theta notation</li><li>Recurrence relations</li><li>Some version of a Master Theorem</li><li>Time and space trade-offs in algorithms</li></ul><li>Algorithmic Strategies</li><ul><li>Branch-and-bound</li><li>Brute-force algorithms</li><li>Divide-and-conquer (cross-reference SDF/Algorithms and Design/Problem-solving strategies)</li><li>Dynamic Programming</li><li>Greedy algorithms</li><li>Heuristics</li><li>Recursive backtracking</li><li>Reduction: transform-and-conquer</li></ul><li>Fundamental Data Structures and Algorithms</li><ul><li>Binary search trees</li><ul><li>Common operations on binary search trees such as select min, max, insert, delete, iterate over tree</li></ul><li>Graphs and graph algorithms</li><ul><li>Depth-first and breadth-first traversals</li><li>Representations of graphs (e.g., adjacency list, adjacency matrix)</li></ul><li>Graphs and graph algorithms</li><ul><li>Minimum spanning tree (Prim's and Kruskal's algorithms)</li><li>Shortest-path algorithms (Dijkstra's and Floyd's algorithms)</li></ul><li>Hash tables, including strategies for avoiding and resolving collisions</li><li>Heaps</li><li>Pattern matching and string/text algorithms (e.g., substring matching, regular expression matching, longest common subsequence algorithms)</li><li>Sequential and binary search algorithms</li><li>Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max, and mode in a list, approximating the square root of a number, or finding the greatest common divisor</li><li>Worst case quadratic sorting algorithms (selection, insertion)</li><li>Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort)</li></ul><li>Basic Automata Computability and Complexity</li><ul><li>Context-free grammars (cross-reference PL/Syntax Analysis)</li><li>Finite-state machines</li><li>Introduction to the NP-complete class and exemplary NP-complete problems (e.g., SAT, Knapsack)</li><li>Introduction to the P and NP classes and the P vs. NP problem</li><li>Regular expressions</li><li>The halting problem</li></ul><li>Advanced Computational Complexity</li><ul><li>Classic NP-complete problems</li><li>NP-completeness (Cook's theorem)</li><li>Polynomial hierarchy</li><li>Reduction Techniques</li><li>Review of the classes P and NP; introduce P-space and EXP</li></ul><li>Advanced Automata Theory and Computability</li><ul><li>Chomsky hierarchy</li><li>Computability</li><li>Context-free languages</li><ul><li>Properties of context-free languages</li><li>Push-down automata (PDAs)</li><li>Relationship of PDAs and context-free grammars</li></ul><li>Examples of uncomputable functions</li><li>Implications of uncomputability</li><li>Nondeterministic Turing machines</li><li>Rice's Theorem</li><li>Sets and languages</li><ul><li>Closure properties</li><li>Equivalence of DFAs and NFAs</li><li>Nondeterministic finite automata (NFAs)</li><li>Proving languages non-regular, via the pumping lemma or alternative means</li><li>Regular languages</li><li>Review of deterministic finite automata (DFAs)</li><li>Review of regular expressions; their equivalence to finite automata</li></ul><li>The Church-Turing thesis</li><li>Turing machines, or an equivalent formal model of universal computation</li></ul><li>Advanced Data Structures Algorithms and Analysis</li><ul><li>Advanced data structures (e.g., B-trees, Fibonacci heaps)</li><li>Amortized analysis</li><li>Approximation algorithms</li><li>Balanced trees (e.g., AVL trees, red-black trees, splay trees, treaps)</li><li>Geometric algorithms (e.g., points, line segments, polygons. [properties, intersections], finding convex hull, spatial decomposition, collision detection, geometric search/proximity)</li><li>Graphs (e.g., topological sort, finding strongly connected components, matching)</li><li>Linear Programming (e.g., duality, simplex method, interior point algorithms)</li><li>Network flows (e.g., max flow [Ford-Fulkerson algorithm], max flow - min cut, maximum bipartite matching)</li><li>Number-theoretic algorithms (e.g., modular arithmetic, primality testing, integer factorization)</li><li>Online algorithms and competitive analysis</li><li>Probabilistic analysis</li><li>Randomized algorithms</li><li>Stochastic algorithms</li><li>String-based data structures and algorithms (e.g., suffix arrays, suffix trees, tries)</li></ul></ul><li>Architecture and Organization </li><ul><li>Digital Logic and Digital Systems</li><ul><li>Combinational vs. sequential logic/Field programmable gate arrays as a fundamental combinational + sequential logic building block</li><li>Computer-aided design tools that process hardware and architectural representations</li><li>Multiple representations/layers of interpretation (hardware is just another layer)</li><li>Overview and history of computer architecture</li><li>Physical constraints (gate delays, fan-in, fan-out, energy/power)</li><li>Register transfer notation/Hardware Description Language (Verilog/VHDL)</li></ul><li>Machine Level Representation of Data</li><ul><li>Bits, bytes, and words</li><li>Fixed- and floating-point systems</li><li>Numeric data representation and number bases</li><li>Representation of non-numeric data (character codes, graphical data)</li><li>Representation of records and arrays</li><li>Signed and twos-complement representations</li></ul><li>Assembly Level Machine Organization</li><ul><li>Addressing modes</li><li>Assembly/machine language programming</li><li>Basic organization of the von Neumann machine</li><li>Control unit; instruction fetch, decode, and execution</li><li>Heap vs. Static vs. Stack vs. Code segments</li><li>I/and interrupts</li><li>Instruction formats</li><li>Instruction sets and types (data manipulation, control, I/O)</li><li>Introduction to SIMD vs. MIMD and the Flynn Taxonomy</li><li>Shared memory multiprocessors/multicore organization</li><li>Subroutine call and return mechanisms (cross-reference PL/Language Translation and Execution)</li></ul><li>Memory System Organization and Architecture</li><ul><li>Cache memories (address mapping, block size, replacement and store policy)</li><li>Error coding, data compression, and data integrity (cross-reference SF/Reliability through Redundancy)</li><li>Fault handling and reliability</li><li>Latency, cycle time, bandwidth, and interleaving</li><li>Main memory organization and operations</li><li>Memory hierarchy: importance of temporal and spatial locality</li><li>Multiprocessor cache consistency/Using the memory system for inter-core synchronization/atomic memory operations</li><li>Storage systems and their technology</li><li>Virtual memory (page table, TLB)</li></ul><li>Interfacing and Communication</li><ul><li>Buses: bus protocols, arbitration, direct-memory access (DMA)</li><li>External storage, physical organization, and drives</li><li>I/fundamentals: handshaking, buffering, programmed I/O, interrupt-driven I/O</li><li>Interrupt structures: vectored and prioritized, interrupt acknowledgment</li><li>Introduction to networks: communications networks as another layer of remote access</li><li>Multimedia support</li><li>RAID architectures</li></ul><li>Functional Organization</li><ul><li>Control unit: hardwired realization vs. microprogrammed realization</li><li>Implementation of simple datapaths, including instruction pipelining, hazard detection and resolution</li><li>Instruction pipelining</li><li>Introduction to instruction-level parallelism (ILP)</li></ul><li>Multiprocessing and Alternative Architectures</li><ul><li>Example SIMD and MIMD instruction sets and architectures</li><li>Interconnection networks (hypercube, shuffle-exchange, mesh, crossbar)</li><li>Multiprocessor cache coherence</li><li>Power Law</li><li>Shared multiprocessor memory systems and memory consistency</li></ul><li>Performance Enhancements</li><ul><li>Alternative architectures, such as VLIW/EPIC, and Accelerators and other kinds of Special-Purpose Processors</li><li>Branch prediction, Speculative execution, Out-of-order execution</li><li>Hardware support for multithreading</li><li>Prefetching</li><li>Scalability</li><li>Superscalar architecture</li><li>Vector processors and GPUs</li></ul></ul><li>Computational Science </li><ul><li>Introduction to Modeling and Simulation</li><ul><li>Foundational approaches to validating models (e.g., comparing a simulation's output to real data or the output of another model)</li><li>Models as abstractions of situations</li><li>Presentation of results in a form relevant to the system being modeled</li><li>Simulation techniques and tools, such as physical simulations, human-in-the-loop guided simulations, and virtual reality</li><li>Simulations as dynamic modeling</li></ul><li>Modeling and Simulation</li><ul><li>Assessing and evaluating models and simulations in a variety of contexts; verification and validation of models and simulations</li><li>Formal models and modeling techniques: mathematical descriptions involving simplifying assumptions and avoiding detail. Examples of techniques include:</li><ul><li>Differential equations: ODE, PDE</li><li>Dynamic programming</li><li>Games, game theory, the modeling of things using game theory</li><li>Graph structures such as directed graphs, trees, networks</li><li>Linear programming and its extensions</li><li>Monte Carlo methods</li><li>Non-linear techniques</li><li>Petri nets and colored Petri nets</li><li>Queuing theory</li><li>State spaces and transitions</li><li>Stochastic processes</li></ul><li>Important application areas including health care and diagnostics, economics and finance, city and urban planning, science, and engineering</li><li>Model building: use of mathematical formulas or equations, graphs, constraints; methodologies and techniques; use of time stepping for dynamic systems</li><li>Purpose of modeling and simulation including optimization; supporting decision making, forecasting, safety considerations; for training and education</li><li>Software in support of simulation and modeling; packages, languages</li><li>The simulation process; identification of key characteristics or behaviors, simplifying assumptions; validation of outcomes</li><li>Tradeoffs including performance, accuracy, validity, and complexity</li></ul><li>Processing</li><ul><li>Computing costs, e.g., the cost of re-computing a value vs. the cost of storing and lookup.</li><li>Fundamental programming concepts:</li><ul><li>Examples of well-known algorithms such as sorting and searching.</li><li>Machine representation of data computer arithmetic.</li><li>Software processes including lifecycle models, requirements, design, implementation, verification and maintenance.</li><li>The concept of an algorithm consisting of a finite number of well-defined steps, each of which completes in a finite amount of time, as does the entire process.</li><li>The concept of analysis as understanding what the problem is really asking, how a problem can be approached using an algorithm, and how information is represented so that a machine can process it.</li><li>The development or identification of a workflow.</li><li>The process of converting an algorithm to machine-executable code.</li></ul><li>Fundamental properties of parallel and distributed computation:</li><ul><li>Bandwidth.</li><li>Grid computing.</li><li>Latency. Scalability. Granularity.</li><li>Parallel architectures including processor architectures, memory and caching.</li><li>Parallel programming paradigms including threading, message passing, event driven techniques, parallel software architectures, and MapReduce.</li><li>Parallelism including task, data, and event parallelism.</li><li>The impact of architecture on computational time.</li><li>Total time to science curve for parallelism: continuum of things.</li></ul><li>Numerical methods</li><ul><li>Algorithms for numerically fitting data (e.g., Newton's method)</li><li>Architectures for numerical computation, including parallel architectures</li></ul></ul><li>Interactive Visualization</li><ul><li>Graphing and visualization algorithms</li><li>Image processing techniques</li><li>Principles of data visualization</li><li>Scalability concerns</li></ul><li>Data, Information, and Knowledge</li><ul><li>Content management models, frameworks, systems, design methods (as in IM. Information Management)</li><li>Content structure / management, including digital libraries and static/dynamic/stream aspects for:</li><ul><li>Data: data structures, databases</li><li>Information: document collections, multimedia pools, hyperbases (hypertext, hypermedia), catalogs, repositories</li><li>Knowledge: ontologies, triple stores, semantic networks, rules</li></ul><li>Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting</li><li>Digital representations of content including numbers, text, images (e.g., raster and vector), vide(e.g.,QuickTime, MPEG2, MPEG4), audio(e.g., written score, MIDI, sampled digitized sound track) and animations; complex/composite/aggregate objects; FRBR</li><li>Modeling, design, logical and physical implementation, using relevant systems/software</li><li>Processing and pattern recognition, including indexing, searching (including: queries and query languages; central / federated / P2P), retrieving, clustering, classifying/categorizing, analyzing/mining/extracting, rendering, reporting, handling transactions</li><li>User / society support for presentation and interaction, including browse, search, filter, route, visualize, share, collaborate, rate, annotate, personalize, recommend</li></ul><li>Numerical Analysis</li><ul><li>Differential equations (Euler's Method, finite differences)</li><li>Error, stability, convergence, including truncation and round-off</li><li>Function approximation including Taylor's series, interpolation, extrapolation, and regression</li><li>Numerical differentiation and integration (Simpson's Rule, explicit and implicit methods)</li></ul></ul><li>Discrete Structures </li><ul><li>Sets, Relations, and Functions</li><ul><li>Functions</li><ul><li>Composition</li><li>Inverses</li><li>Surjections, injections, bijections</li></ul><li>Relations</li><ul><li>Equivalence relations, partial orders</li><li>Reflexivity, symmetry, transitivity</li></ul><li>Sets</li><ul><li>Cardinality of finite sets</li><li>Cartesian product</li><li>Power sets</li><li>Union, intersection, complement</li><li>Venn diagrams</li></ul></ul><li>Basic Logic</li><ul><li>Limitations of propositional and predicate logic (e.g., expressiveness issues)</li><li>Logical connectives</li><li>Normal forms (conjunctive and disjunctive)</li><li>Predicate logic</li><ul><li>Universal and existential quantification</li></ul><li>Propositional inference rules (concepts of modus ponens and modus tollens)</li><li>Propositional logic (cross-reference: Propositional logic is also reviewed in IS/Knowledge Based Reasoning)</li><li>Truth tables</li><li>Validity of well-formed formula</li></ul><li>Proof Techniques</li><ul><li>Direct proofs</li><li>Disproving by counterexample</li><li>Induction over natural numbers</li><li>Notions of implication, equivalence, converse, inverse, contrapositive, negation, and contradiction</li><li>Proof by contradiction</li><li>Recursive mathematical definitions</li><li>Structural induction</li><li>The structure of mathematical proofs</li><li>Weak and strong induction (i.e., First and Second Principle of Induction)</li><li>Well orderings</li></ul><li>Basics of Counting</li><ul><li>Basic modular arithmetic</li><li>Counting arguments</li><ul><li>Arithmetic and geometric progressions</li><li>Inclusion-exclusion principle</li><li>Set cardinality and counting</li><li>Sum and product rule</li></ul><li>Permutations and combinations</li><ul><li>Basic definitions</li><li>Pascal's identity</li><li>The binomial theorem</li></ul><li>Solving recurrence relations (cross-reference: AL/Basic Analysis)</li><ul><li>An example of a simple recurrence relation, such as Fibonacci numbers</li><li>Other examples, showing a variety of solutions</li></ul><li>The pigeonhole principle</li></ul><li>Graphs and Trees</li><ul><li>Directed graphs</li><li>Graph isomorphism</li><li>Spanning trees/forests</li><li>Trees</li><ul><li>Properties</li><li>Traversal strategies</li></ul><li>Undirected graphs</li><li>Weighted graphs</li></ul><li>Discrete Probability</li><ul><li>Axioms of probability and probability measures</li><li>Conditional Independence</li><li>Conditional probability, Bayes' theorem</li><li>Expectation, including Linearity of Expectation</li><li>Finite probability space, events</li><li>Independence</li><li>Integer random variables (Bernoulli, binomial)</li><li>Variance</li></ul></ul><li>Graphics and Visualization </li><ul><li>Fundamental Concepts</li><ul><li>Additive and subtractive color models (CMYK and RGB) and why these provide a range of colors</li><li>Animation as a sequence of still images</li><li>Digitization of analog data, resolution, and the limits of human perception, e.g., pixels for visual display, dots for laser printers, and samples for audio(HCI/Foundations)</li><li>Double buffering</li><li>Media applications including user interfaces, audio and video editing, game engines, cad, visualization, virtual reality</li><li>Standard media formats, including lossless and lossy formats</li><li>Tradeoffs between storing data and re-computing data as embodied by vector and raster representations of images</li><li>Use of standard APIs for the construction of UIs and display of standard media formats (see HCI/GUI construction)</li></ul><li>Basic Rendering</li><ul><li>Affine and coordinate system transformations</li><li>Application of spatial data structures to rendering</li><li>Basic radiometry, similar triangles, and projection model</li><li>Forward and backward rendering (i.e., ray-casting and rasterization)</li><li>Polygonal representation</li><li>Ray tracing</li><li>Rendering in nature, e.g., the emission and scattering of light and its relation to numerical integration</li><li>Rendering with a shader-based API</li><li>Sampling and anti-aliasing</li><li>Scene graphs and the graphics pipeline</li><li>Simple triangle rasterization</li><li>Texture mapping, including minification and magnification (e.g., trilinear MIP-mapping)</li><li>The forward and backward rendering equation</li><li>Visibility and occlusion, including solutions tthis problem such as depth buffering, Painter's algorithm, and ray tracing</li></ul><li>Geometric Modeling</li><ul><li>Approximation techniques such as polynomial curves, Bezier curves, spline curves and surfaces, and non-uniform rational basis (NURB) spines, and level set method</li><li>Basic geometric operations such as intersection calculation and proximity tests</li><li>Constructive Solid Geometry (CSG) representation</li><li>Elastically deformable and freeform deformable models</li><li>Graftals, cross referenced with programming languages (grammars to generated pictures)</li><li>Implicit representation of curves and surfaces</li><li>Multiresolution modeling</li><li>Parametric polynomial curves and surfaces</li><li>Procedural models such as fractals, generative modeling, and L-systems</li><li>Reconstruction</li><li>Spatial subdivision techniques</li><li>Subdivision surfaces</li><li>Surface representation techniques including tessellation, mesh representation, mesh fairing, and mesh generation techniques such as Delaunay triangulation, marching cubes</li><li>Volumes, voxels, and point-based representations</li></ul><li>Advanced Rendering</li><ul><li>Area light sources</li><li>Bidirectional Scattering Distribution function (BSDF) theory and microfacets</li><li>GPU architecture</li><li>Hierarchical depth buffering</li><li>Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion</li><li>Non-photorealistic rendering</li><li>Occlusion culling</li><li>Shadow mapping</li><li>Solutions and approximations to the rendering equation, for example:</li><ul><li>Bidirectional path tracing</li><li>Distribution ray tracing and path tracing</li><li>Metropolis light transport</li><li>Photon mapping</li><li>Reyes (micropolygon) rendering</li></ul><li>Subsurface scattering</li><li>The Light Field, image-based rendering</li><li>Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on rendering</li></ul><li>Computer Animation</li><ul><li>Camera animation</li><li>Collision detection and response</li><li>Data structures for rotations, such as quaternions</li><li>Forward and inverse kinematics</li><li>Key-frame animation</li><li>Motion capture</li><li>Physics based motions including rigid body dynamics, physical particle systems, mass-spring networks for cloth and flesh and hair</li><li>Procedural animation using noise, rules (boids/crowds), and particle systems</li><li>Skinning algorithms</li><li>Splines</li></ul><li>Visualization</li><ul><li>Applications of visualization</li><li>Direct volume data rendering: ray-casting, transfer functions, segmentation</li><li>Evaluation of visualization methods</li><li>Perceptual and cognitive foundations that drive visual abstractions</li><li>Visualization design</li><li>Visualization of 2D/3D scalar fields: color mapping, isosurfaces</li><li>Visualization of:</li><ul><li>High-dimensional data: dimension reduction, parallel coordinates</li><li>Non-spatial data: multi-variate, tree/graph structured, text</li><li>Time-varying data</li><li>Vector fields and flow data</li></ul></ul></ul><li>Human-Computer Interaction </li><ul><li>Foundations</li><ul><li>Accessibility, e.g., interfaces for differently-abled populations (e.g., blind, motion-impaired)</li><li>Cognitive models that inform interaction design, e.g., attention, perception and recognition, movement, and memory; gulfs of expectation and execution</li><li>Contexts for HCI (anything with a user interface, e.g., webpage, business applications, mobile applications, and games)</li><li>Different measures for evaluation, e.g., utility, efficiency, learnability, user satisfaction</li><li>Interfaces for differently-aged population groups (e.g., children, 80+)</li><li>Physical capabilities that inform interaction design, e.g., color perception, ergonomics</li><li>Principles of good design and good designers; engineering tradeoffs</li><li>Processes for user-centered development, e.g., early focus on users, empirical testing, iterative design</li><li>Social models that inform interaction design, e.g., culture, communication, networks and organizations</li><li>Usability heuristics and the principles of usability testing</li></ul><li>Designing Interaction</li><ul><li>Elements of visual design (layout, color, fonts, labeling)</li><li>Handling human/system failure</li><li>Help and documentation</li><li>Low-fidelity (paper) prototyping</li><li>Principles of graphical user interfaces (GUIs)</li><li>Quantitative evaluation techniques, e.g., keystroke-level evaluation</li><li>Task analysis, including qualitative aspects of generating task analytic models</li><li>User interface standards</li></ul><li>Programming Interactive Systems</li><ul><li>Choosing interaction styles and interaction techniques</li><li>Cross-platform design</li><li>Data-driven applications (database-backed web pages)</li><li>Declarative Interface Specification: Stylesheets and DOMs</li><li>Design for resource-constrained devices (e.g. small, mobile devices)</li><li>Event management and user interaction</li><li>Geometry management (cross-reference GV/Geometric Modelling)</li><li>Interaction Design Patterns: visual hierarchy, navigational distance</li><li>Interface animation techniques (e.g., scene graphs)</li><li>Modern GUI libraries (e.g. iOS, Android, JavaFX) GUI builders and UI programming environments (cross-reference PBD/Mobile Platforms)</li><li>Presenting information: navigation, representation, manipulation</li><li>Software Architecture Patterns, e.g., Model-View controller; command objects, online, offline (cross reference PL/Event Driven and Reactive Programming, where MVC is used in the context of event-driven programming)</li><li>Widget classes and libraries</li></ul><li>User-Centered Design and Testing</li><ul><li>Approaches to, and characteristics of, the design process</li><li>Challenges to effective evaluation, e.g., sampling, generalization</li><li>Evaluation with users, e.g., observation, think-aloud, interview, survey, experiment</li><li>Evaluation without users, using both qualitative and quantitative techniques, e.g., walkthroughs, GOMS, expert-based analysis, heuristics, guidelines, and standards</li><li>Functionality and usability requirements (cross-reference to SE/Requirements Engineering)</li><li>Internationalization, designing for users from other cultures, cross-cultural</li><li>Prototyping techniques and tools, e.g., sketching, storyboards, low-fidelity prototyping, wireframes</li><li>Reporting the results of evaluations</li><li>Techniques and tools for the analysis and presentation of requirements, e.g., reports, personas</li><li>Techniques for gathering requirements, e.g., interviews, surveys, ethnographic and contextual enquiry</li></ul><li>New Interactive Technologies</li><ul><li>Approaches to design, implementation and evaluation of non-mouse interaction</li><ul><li>Ambient/peripheral display and interaction</li><li>Bayesian inference (e.g. predictive text, guided pointing)</li><li>New Windows, e.g., iPhone, Android</li><li>New input modalities (such as sensor and location data)</li><li>Shared, embodied, and large interfaces</li><li>Speech recognition and natural language processing (cross reference IS/Natural Language Processing)</li><li>Touch and multi-touch interfaces</li><li>Ubiquitous and context-aware interaction technologies (Ubicomp)</li><li>Wearable and tangible interfaces Persuasive interaction and emotion</li></ul><li>Choosing interaction styles and interaction techniques</li><li>Representing information to users: navigation, representation, manipulation</li></ul><li>Collaboration and Communication</li><ul><li>Asynchronous group communication, e.g., e-mail, forums, social networks</li><li>Online collaboration, 'smart' spaces, and social coordination aspects of workflow technologies</li><li>Online communities</li><li>Social media, social computing, and social network analysis</li><li>Social psychology</li><li>Software characters and intelligent agents, virtual worlds and avatars (cross-reference IS/Agents)</li><li>Synchronous group communication, e.g., chat rooms, conferencing, online games</li></ul><li>Statistical Methods for HCI</li><ul><li>ANOVA</li><li>Calculating effect size</li><li>Combining qualitative and quantitative results</li><li>Exploratory data analysis</li><li>Presenting statistical data</li><li>Randomization (non-parametric) testing, within vs. between-subjects design</li><li>t-tests</li></ul><li>Human Factors and Security</li><ul><li>Applied psychology and security policies</li><li>Biometric authentication (camera, voice)</li><li>Identity management</li><li>Organizational vulnerabilities and threats</li><li>Pretext, impersonation and fraud, e.g., phishing and spear phishing (cross-reference IAS/Threats and Attacks)</li><li>Regulatory environments - responsibility, liability and self-determination</li><li>Security economics</li><li>Trust, privacy and deception</li><li>Usability design and security</li></ul><li>Design-Oriented HCI</li><ul><li>Consideration of HCI as a design discipline</li><ul><li>Participatory design</li><li>Sketching</li></ul><li>Critically reflective HCI</li><ul><li>Critical technical practice</li><li>Ethnography and ethnomethodology</li><li>Philosophy of user experience</li><li>Technologies for political activism</li></ul><li>Indicative domains of application</li><ul><li>Arts-informed computing</li><li>Sustainability</li></ul><li>Intellectual styles and perspectives to technology and its interfaces</li></ul><li>Mixed, Augmented and Virtual Reality</li><ul><li>Networking</li><ul><li>Distributed collaboration</li><li>p2p, client-server, dead reckoning, encryption, synchronization</li></ul><li>Output</li><ul><li>Force feedback simulation, haptic devices</li><li>Sound</li><li>Stereoscopic display</li></ul><li>Physical modelling and rendering</li><ul><li>Physical simulation: collision detection & response, animation</li><li>Time-critical rendering, multiple levels of details (LOD)</li><li>Visibility computation</li></ul><li>System architectures</li><ul><li>CAVEs</li><li>Flight simulators</li><li>Game engines</li><li>Medical imaging</li><li>Mobile augmented reality</li></ul><li>User input</li><ul><li>Accelerometers</li><li>Fiducial markers</li><li>Pose and gesture recognition</li><li>User interface issues</li><li>Viewer and object tracking</li></ul></ul></ul><li>Information Assurance and Security </li><ul><li>Foundational Concepts in Security</li><ul><li>Authentication and authorization, access control (mandatory vs. discretionary)</li><li>CIA (Confidentiality, Integrity, Availability)</li><li>Concept of trust and trustworthiness</li><li>Concepts of risk, threats, vulnerabilities, and attack vectors (cross- reference SE/Software Project Management/Risk)</li><li>Ethics (responsible disclosure). (cross-reference SP/Professional Ethics/Accountability, responsibility and liability)</li></ul><li>Principles of Secure Design</li><ul><li>Complete mediation</li><li>Defense in depth (e.g., defensive programming, layered defense)</li><li>Economy of mechanism (reducing trusted computing base, minimize attack surface) (cross-reference SE/Software Design/System design principles and SE/Software Construction/Development context: 'green field' vs. existing code base)</li><li>End-to-end security (cross-reference SF/Reliability through Redundancy/ How errors increase the longer the distance between the communicating entities; the end-to-end principle)</li><li>Fail-safe defaults (cross-reference SE/Software Construction/ Coding practices: techniques, idioms/patterns, mechanisms for building quality programs and SDF/Development Methods/Programming correctness)</li><li>Least privilege and isolation (cross-reference OS/Security and Protection/Policy/mechanism separation and SF/Virtualization and Isolation/Rationale for protection and predictable performance and PL/Language Translation and Execution/Memory management)</li><li>Open design (cross-reference SE/Software Evolution/ Software development in the context of large, pre-existing code bases)</li><li>Prevention, detection, and deterrence (cross-reference SF/Reliability through Redundancy/Distinction between bugs and faults and NC/Reliable Data Delivery/Error control and NC/Reliable Data Delivery/Flow control)</li><li>Security by design (cross-reference SE/Software Design/System design principles)</li><li>Security composability</li><li>Tensions between security and other design goals</li><li>Usable security (cross-reference HCI/Foundations/Cognitive models that inform interaction design)</li><li>Use of vetted security components</li></ul><li>Defensive Programming</li><ul><li>Choice of programming language and type-safe languages</li><li>Correct handling of exceptions and unexpected behaviors (cross-reference SDF/Development Methods/program correctness)</li><li>Correct usage of third-party components (cross-reference SDF/Development Methods/program correctness and Operating System Principles/Concepts of application program interfaces (APIs)</li><li>Correctly generating randomness for security purposes</li><li>Effectively deploying security updates (cross-reference OS/Security and Protection/Security methods and devices)</li><li>Examples of input validation and data sanitization errors (cross-reference SDF/Development Methods/Program Correctness and SE/Software Construction/Coding Practices)</li><ul><li>Buffer overflows</li><li>Integer errors</li><li>SQL injection</li><li>XSS vulnerability</li></ul><li>Fuzzing</li><li>Hardware support (e.g., DEP, TPM)</li><li>Information flow control</li><li>Input validation and data sanitization (cross-reference SDF/Development Methods/Program Correctness)</li><li>Mechanisms for detecting and mitigating input and data sanitization errors</li><li>Operating system support (e.g., address space randomization, canaries)</li><li>Program verification</li><li>Race conditions (cross-reference SF/Parallelism/Parallel programming and PD/Parallel Architecture/Shared vs. distributed memory and PD/Communication and Coordination/Shared Memory and PD/Parallelism Fundamentals/Programming errors not found in sequential programming)</li><li>Static analysis and dynamic analysis</li><li>[Electives]</li></ul><li>Threats and Attacks</li><ul><li>Attacker goals, capabilities, and motivations (such as underground economy, digital espionage, cyberwarfare, insider threats, hacktivism, advanced persistent threats)</li><li>Attacks on privacy and anonymity (cross-reference HCI/Foundations/Social models that inform interaction design: culture, communication, networks and organizations (cross-reference SP/Privacy and Civil Liberties/technology-based solutions for privacy protection)</li><li>Denial of Service (DoS) and Distributed Denial of Service (DDoS)</li><li>Examples of malware (e.g., viruses, worms, spyware, botnets, Trojan horses or rootkits)</li><li>Malware/unwanted communication such as covert channels and steganography</li><li>Social engineering (e.g., phishing) (cross-reference SP/Social Context/Social implications of computing in a networked world and HCI/Designing Interaction/Handling human/system failure)</li></ul><li>Network Security</li><ul><li>Architectures for secure networks (e.g., secure channels, secure routing protocols, secure DNS, VPNs, anonymous communication protocols, isolation)</li><li>Censorship resistance</li><li>Defense mechanisms and countermeasures (e.g., network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots, tracebacks)</li><li>Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic redirection, man-in-the-middle, message integrity attacks, routing attacks, and traffic analysis)</li><li>Operational network security management (e.g., configure network access control)</li><li>Other non-wired networks (e.g., ad hoc, sensor, and vehicular networks)</li><li>Security for wireless, cellular networks (cross-reference NC/Mobility/Principles of cellular networks; cross-reference NC/Mobility/802.11)</li><li>Use of cryptography for data and network security</li></ul><li>Cryptography</li><ul><li>Authenticated key exchange protocols, e.g., TLS</li><li>Basic Cryptography Terminology covering notions pertaining to the different (communication) partners, secure/unsecure channel, attackers and their capabilities, encryption, decryption, keys and their characteristics, signatures</li><li>Cipher types (e.g., Caesar cipher, affine cipher) together with typical attack methods such as frequency analysis</li><li>Cryptographic primitives:</li><ul><li>block ciphers (pseudo-random permutations), e.g., AES</li><li>hash functions, e.g., SHA2, collision resistance</li><li>key derivations functions</li><li>message authentication codes</li><li>pseudo-random functions</li><li>pseudo-random generators and stream ciphers</li></ul><li>Cryptographic protocols: challenge-response authentication, zero-knowledge protocols, commitment, oblivious transfer, secure 2-party or multi-party computation, secret sharing, and applications</li><li>Cryptographic standards and references implementations</li><li>Mathematical Preliminaries essential for cryptography, including topics in linear algebra, number theory, probability theory, and statistics</li><li>Motivate concepts using real-world applications, e.g., electronic cash, secure channels between clients and servers, secure electronic mail, entity authentication, device pairing, voting systems.</li><li>Public Key Infrastructure support for digital signature and encryption and its challenges</li><li>Public key cryptography:</li><ul><li>Digital signatures</li><li>Hardness assumptions, e.g., Diffie-Hellman, integer factoring</li><li>Public key encryption, e.g., RSA encryption, EI Gamal encryption</li><li>Public-key infrastructure (PKI) and certificates</li><li>Trapdoor permutation, e.g., RSA</li></ul><li>Quantum cryptography</li><li>Security definitions and attacks on cryptographic primitives:</li><ul><li>Attacker capabilities: chosen-message attack (for signatures), birthday attacks, side channel attacks, fault injection attacks.</li><li>Goals: indistinguishability, unforgeability, collision-resistance</li></ul><li>Symmetric key cryptography</li><ul><li>Message integrity (e.g., CMAC, HMAC)</li><li>Modes of operation for semantic security and authenticated encryption (e.g., encrypt-then-MAC, OCB, GCM)</li><li>Perfect secrecy and the one time pad</li></ul></ul><li>Web Security</li><ul><li>Application vulnerabilities and defenses</li><ul><li>CSRF</li><li>SQL injection</li><li>XSS</li></ul><li>Client-side security</li><ul><li>Cookies security policy</li><li>HTTP security extensions, e.g. HSTS</li><li>Plugins, extensions, and web apps</li><li>Web user tracking</li></ul><li>Server-side security tools, e.g. Web Application Firewalls (WAFs) and fuzzers</li><li>Session management, authentication</li><ul><li>HTTPS and certificates</li><li>Single sign-on</li></ul><li>Web security model</li><ul><li>Browser security model including same-origin policy</li><li>Client-server trust boundaries, e.g., cannot rely on secure execution in the client</li></ul></ul><li>Platform Security</li><ul><li>Attestation</li><li>Code integrity and code signing</li><li>Physical attacks: hardware Trojans, memory probes, cold boot attacks</li><li>Secure boot, measured boot, and root of trust</li><li>Security of embedded devices, e.g., medical devices, cars</li><li>Security threats from peripherals, e.g., DMA, IOMMU</li><li>TPM and secure co-processors</li><li>Trusted path</li></ul><li>Security Policy and Governance</li><ul><li>Backup policy, password refresh policy</li><li>Breach disclosure policy</li><li>Cloud security tradeoffs</li><li>Data collection and retention policies</li><li>Inference controls/statistical disclosure limitation</li><li>Privacy policy (cross-reference SP/Social Context/Social implications of computing in a networked world; cross-reference SP/Professional Ethics/Accountability, responsibility and liability; cross-reference SP/Privacy and Civil Liberties/Legal foundations of privacy protection)</li><li>Supply chain policy</li></ul><li>Digital Forensics</li><ul><li>Anti-forensics</li><li>Application Forensics</li><li>Attack detection and investigation</li><li>Basic Principles and methodologies for digital forensics</li><li>Computer/network/system attacks</li><li>Design systems with forensic needs in mind</li><li>Digital Evidence methods and standards</li><li>Legal and Reporting Issues including working as an expert witness</li><li>Mobile Device Forensics</li><li>Network Forensics</li><li>OS/File System Forensics</li><li>Rules of Evidence - general concepts and differences between jurisdictions and Chain of Custody</li><li>Search and Seizure of evidence: legal and procedural requirements</li><li>Techniques and standards for Preservation of Data</li><li>Web Forensics</li></ul><li>Secure Software Engineering</li><ul><li>Building security into the software development lifecycle (cross-reference SE/Software Processes)</li><li>Secure design principles and patterns</li><li>Secure software development practices (cross-reference SE/Software Construction)</li><li>Secure software specifications and requirements</li><li>Secure testing - the process of testing that security requirements are met (including static and dynamic analysis).</li><li>Software quality assurance and benchmarking measurements</li></ul></ul><li>Information Management </li><ul><li>Information Management Concepts</li><ul><li>Analysis and indexing</li><li>Basic information storage and retrieval (IS&R) concepts</li><li>Declarative and navigational queries, use of links</li><li>Information capture and representation</li><li>Information management applications</li><li>Information systems as socio-technical systems</li><li>Quality issues: reliability, scalability, efficiency, and effectiveness</li><li>Supporting human needs: searching, retrieving, linking, browsing, navigating</li></ul><li>Database Systems</li><ul><li>Approaches for managing large volumes of data (e.g., noSQL database systems, use of MapReduce).</li><li>Approaches to and evolution of database systems</li><li>Components of database systems</li><li>Database architecture and data independence</li><li>Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer management, access methods)</li><li>Systems supporting structured and/or stream content</li><li>Use of a declarative query language</li></ul><li>Data Modeling</li><ul><li>Conceptual models (e.g., entity-relationship, UML diagrams)</li><li>Data modeling</li><li>Object-oriented models (cross-reference PL/Object-Oriented Programming)</li><li>Relational data models</li><li>Semi-structured data model (expressed using DTD or XML Schema, for example)</li><li>Spreadsheet models</li></ul><li>Indexing</li><ul><li>Creating indexes with SQL</li><li>Indexing text</li><li>Indexing the web (e.g., web crawling)</li><li>Keeping a buffer of data in memory</li><li>The basic structure of an index</li><li>The impact of indices on query performance</li></ul><li>Relational Databases</li><ul><li>Candidate keys, superkeys, and closure of a set of attributes</li><li>Decomposition of a schema; lossless-join and dependency-preservation properties of a decomposition</li><li>Entity and referential integrity</li><li>Functional dependency</li><li>Join dependency (PJNF, 5NF)</li><li>Mapping conceptual schema ta relational schema</li><li>Multi-valued dependency (4NF)</li><li>Normal forms (BCNF)</li><li>Relational Database design</li><li>Relational algebra and relational calculus</li><li>Representation theory</li></ul><li>Query Languages</li><ul><li>Aggregates and group-by</li><li>Different ways to invoke non-procedural queries in conventional languages</li><li>Introduction to other major query languages (e.g., XPATH, SPARQL)</li><li>Overview of database languages</li><li>Projections</li><li>QBE and 4th-generation environments</li><li>SQL (data definition, query formulation, update sublanguage, constraints, integrity)</li><li>Select-project-join</li><li>Selections</li><li>Stored procedures</li><li>Subqueries</li></ul><li>Transaction Processing</li><ul><li>Concurrency control</li><li>Failure and recovery</li><li>Interaction of transaction management with storage, especially buffering</li><li>Transactions</li></ul><li>Distributed Databases</li><ul><li>Distributed DBMS</li><ul><li>Client-server distributed databases (cross-reference SF/Computational Paradigms)</li><li>Distributed data storage</li><li>Distributed query processing</li><li>Distributed transaction model</li><li>Homogeneous and heterogeneous solutions</li></ul><li>Parallel DBMS</li><ul><li>Data replication and weak consistency models</li><li>Parallel DBMS architectures: shared memory, shared disk, shared nothing;</li><li>Speedup and scale-up, e.g., use of the MapReduce processing model (cross-reference CN/Processing, PD/Parallel Decomposition)</li></ul></ul><li>Physical Database Design</li><ul><li>B-trees</li><li>Database efficiency and tuning</li><li>Files with dense index</li><li>Files with variable length records</li><li>Hashed files</li><li>Indexed files</li><li>Signature files</li><li>Storage and file structure</li></ul><li>Data Mining</li><ul><li>Associative and sequential patterns</li><li>Data cleaning</li><li>Data clustering</li><li>Data mining algorithms</li><li>Data visualization (cross-reference GV/Visualization and CN/Interactive Visualization)</li><li>Market basket analysis</li><li>Uses of data mining</li></ul><li>Information Storage and Retrieval</li><ul><li>Architectures (agents, buses, wrappers/mediators), interoperability</li><li>Archiving and preservation, integrity</li><li>Bibliographic information, bibliometrics, citations</li><li>Digital libraries</li><li>Digitization, storage, interchange, digital objects, composites, and packages</li><li>Documents, electronic publishing, markup, and markup languages</li><li>Faceted search (e.g., using citations, keywords, classification schemes)</li><li>Information needs, relevance, evaluation, effectiveness</li><li>Information summarization and visualization</li><li>Intellectual property rights management, privacy, and protection (watermarking)</li><li>Metadata and cataloging</li><li>Morphological analysis, stemming, phrases, stop lists</li><li>Multimedia search, information seeking behavior, user modeling, feedback</li><li>Naming, repositories, archives</li><li>Routing and (community) filtering</li><li>Services (searching, linking, browsing, and so forth)</li><li>Spaces (conceptual, geographical, 2/3D, VR)</li><li>Term frequency distributions, uncertainty, fuzziness, weighting</li><li>Thesauri, ontologies, classification and categorization, metadata</li><li>Tries, inverted files, PAT trees, signature files, indexing</li><li>Vector space, probabilistic, logical, and advanced models</li></ul><li>Multimedia Systems</li><ul><li>Applications, media editors, authoring systems, and authoring</li><li>Content-based analysis, indexing, and retrieval of audio, images, animation, and video</li><li>Input and output devices, device drivers, control signals and protocols, DSPs</li><li>Presentation, rendering, synchronization, multi-modal integration/interfaces</li><li>Real-time delivery, quality of service (including performance), capacity planning, audio/videconferencing, video-on-demand</li><li>Standards (e.g., audio, graphics, video)</li><li>Streams/structures, capture/represent/transform, spaces/domains, compression/coding</li></ul></ul><li>Intelligent Systems </li><ul><li>Fundamental Issues</li><ul><li>Nature of agents</li><ul><li>Autonomous versus semi-autonomous</li><li>Reflexive, goal-based, and utility-based</li><li>The importance of perception and environmental interactions</li></ul><li>Overview of AI problems, examples of successful recent AI applications</li><li>Philosophical and ethical issues. [elective]</li><li>Problem characteristics</li><ul><li>Deterministic versus stochastic</li><li>Discrete versus continuous</li><li>Fully versus partially observable</li><li>Single versus multi-agent</li><li>Static versus dynamic</li></ul><li>What is intelligent behavior?</li><ul><li>Rational versus non-rational reasoning</li><li>The Turing test</li></ul></ul><li>Basic Search Strategies</li><ul><li>Constraint satisfaction (backtracking and local search methods)</li><li>Factored representation (factoring state into variables)</li><li>Heuristics and informed search (hill-climbing, generic best-first, A*)</li><li>Problem spaces (states, goals and operators), problem solving by search</li><li>Space and time efficiency of search</li><li>Two-player games (introduction to minimax search)</li><li>Uninformed search (breadth-first, depth-first, depth-first with iterative deepening)</li></ul><li>Basic Knowledge Representation and Reasoning</li><ul><li>Forward chaining, backward chaining</li><li>Resolution and theorem proving (propositional logic only)</li><li>Review of probabilistic reasoning, Bayes theorem (cross-reference with DS/Discrete Probability)</li><li>Review of propositional and predicate logic (cross-reference DS/Basic Logic)</li></ul><li>Basic Machine Learning</li><ul><li>Definition and examples of broad variety of machine learning tasks, including classification</li><li>Inductive learning</li><li>Measuring classifier accuracy</li><li>Simple statistical-based learning, such as Naive Bayesian Classifier, decision trees</li><li>The over-fitting problem</li></ul><li>Advanced Search</li><ul><li>Constructing search trees, dynamic search space, combinatorial explosion of search space</li><li>Expectimax search (MDP-solving) and chance nodes</li><li>Implementation of A* search, beam search</li><li>Minimax search, alpha-beta pruning</li><li>Stochastic search</li><ul><li>Genetic algorithms</li><li>Monte-Carlo tree search</li><li>Simulated annealing</li></ul></ul><li>Advanced Representation and Reasoning</li><ul><li>Argumentation</li><li>Knowledge representation issues</li><ul><li>Description logics</li><li>Ontology engineering</li></ul><li>Model-based and Case-based reasoning</li><li>Non-monotonic reasoning (e.g., non-classical logics, default reasoning)</li><li>Planning:</li><ul><li>Hierarchical planning</li><li>Mobile agent/Multi-agent planning</li><li>Partial and totally ordered planning</li><li>Plan graphs</li><li>Planning and execution including conditional planning and continuous planning</li></ul><li>Reasoning about action and change (e.g., situation and event calculus)</li><li>Rule-based Expert Systems</li><li>Semantic networks</li><li>Temporal and spatial reasoning</li></ul><li>Reasoning Under Uncertainty</li><ul><li>Conditional Independence</li><li>Decision Theory</li><ul><li>Maximizing expected utility</li><li>Preferences and utility functions</li></ul><li>Knowledge representations</li><ul><li>Bayesian Networks</li><ul><li>Exact inference and its complexity</li><li>Randomized sampling (Monte Carlo) methods (e.g. Gibbs sampling)</li></ul><li>Hidden Markov Models</li><li>Markov Networks</li><li>Relational probability models</li></ul><li>Random variables and probability distributions</li><ul><li>Axioms of probability</li><li>Bayes' Rule</li><li>Probabilistic inference</li></ul><li>Review of basic probability (cross-reference DS/Discrete Probability)</li></ul><li>Agents</li><ul><li>Agent architectures (e.g., reactive, layered, cognitive)</li><li>Agent theory</li><li>Definitions of agents</li><li>Learning agents</li><li>Multi-agent systems</li><ul><li>Agent teams</li><li>Collaborating agents</li><li>Competitive agents (e.g., auctions, voting)</li><li>Swarm systems and biologically inspired models</li></ul><li>Rationality, game theory</li><ul><li>Decision-theoretic agents</li><li>Markov decision processes (MDP)</li></ul><li>Software agents, personal assistants, and information access</li><ul><li>Believable agents (synthetic characters, modeling emotions in agents)</li><li>Collaborative agents</li><li>Information-gathering agents</li></ul></ul><li>Natural Language Processing</li><ul><li>Corpus-based methods</li><li>Deterministic and stochastic grammars</li><li>Examples of use: POS tagging and morphology</li><li>Information extraction</li><li>Information retrieval (Cross-reference IM/Information Storage and Retrieval)</li><ul><li>Precision and recall</li><li>Vector space model</li><ul><li>TF & IDF</li></ul></ul><li>Language translation</li><li>N-grams and HMMs</li><li>Parsing algorithms</li><ul><li>CFGs and chart parsers (e.g. CYK)</li><li>Probabilistic CFGs and weighted CYK</li></ul><li>Representing meaning / Semantics</li><ul><li>Beliefs, desires, and intentions</li><li>Logic-based knowledge representations</li><li>Semantic roles</li><li>Temporal representations</li></ul><li>Smoothing and backoff</li><li>Text classification, categorization</li><ul><li>Bag of words model</li></ul></ul><li>Advanced Machine Learning</li><ul><li>Application of Machine Learning algorithms to Data Mining (cross-reference IM/Data Mining)</li><li>Definition and examples of broad variety of machine learning tasks</li><li>Ensembles</li><li>General statistical-based learning, parameter estimation (maximum likelihood)</li><li>Inductive logic programming (ILP)</li><li>Learning graphical models (Cross-reference IS/Reasoning under Uncertainty)</li><li>Learning theory</li><li>Nearest-neighbor algorithms</li><li>Performance evaluation (such as cross-validation, area under ROC curve)</li><li>Reinforcement learning</li><ul><li>Exploration vs. exploitation trade-off</li><li>Markov decision processes Value and policy iteration</li></ul><li>Semi-supervised learning</li><li>Supervised learning</li><ul><li>Learning decision trees</li><li>Learning neural networks</li><li>Support vector machines (SVMs)</li></ul><li>The problem of overfitting, the curse of dimensionality</li><li>Unsupervised Learning and clustering</li><ul><li>EM</li><li>K-means</li><li>Self-organizing maps</li></ul></ul><li>Robotics</li><ul><li>Configuration space and environmental maps</li><li>Interpreting uncertain sensor data</li><li>Localizing and mapping</li><li>Motion planning</li><li>Multiple-robot coordination</li><li>Navigation and control</li><li>Overview: problems and progress</li><ul><li>Inherent uncertainty in sensing and in control</li><li>Robot control architectures, e.g., deliberative vs. reactive control and Braitenberg vehicles</li><li>State-of-the-art robot systems, including their sensors and an overview of their sensor processing</li><li>World modeling and world models</li></ul></ul><li>Perception and Computer Vision</li><ul><li>Approaches to pattern recognition (cross-reference IS/Advanced Machine Learning)</li><ul><li>Classification algorithms and measures of classification quality</li><li>Statistical techniques</li></ul><li>Audio and speech recognition</li><li>Computer vision</li><ul><li>Image acquisition, representation, processing and properties</li><li>Motion analysis</li><li>Shape representation, object recognition and segmentation</li></ul><li>Modularity in recognition</li></ul></ul><li>Networking and Communication </li><ul><li>Introduction</li><ul><li>Layering principles (encapsulation, multiplexing)</li><li>Organization of the Internet (Internet Service Providers, Content Providers, etc.)</li><li>Physical pieces of a network, including hosts, routers, switches, ISPs, wireless, LAN, access point, and firewalls</li><li>Roles of the different layers (application, transport, network, datalink, physical)</li><li>Switching techniques (e.g., circuit, packet)</li></ul><li>Networked Applications</li><ul><li>Distributed applications (client/server, peer-to-peer, cloud, etc.)</li><li>HTTP as an application layer protocol</li><li>Multiplexing with TCP and UDP</li><li>Naming and address schemes (DNS, IP addresses, Uniform Resource Identifiers, etc.)</li><li>Socket APIs</li></ul><li>Reliable Data Delivery</li><ul><li>Error control (retransmission techniques, timers)</li><li>Flow control (acknowledgements, sliding window)</li><li>Performance issues (pipelining)</li><li>TCP</li></ul><li>Routing and Forwarding</li><ul><li>Internet Protocol (IP)</li><li>Routing versus forwarding</li><li>Scalability issues (hierarchical addressing)</li><li>Static routing</li></ul><li>Local Area Networks</li><ul><li>Common approaches to multiple access (exponential-backoff, time division multiplexing, etc)</li><li>Ethernet</li><li>Local Area Networks</li><li>Multiple Access Problem</li><li>Switching</li></ul><li>Resource Allocation</li><ul><li>Approaches to Congestion (e.g., Content Distribution Networks)</li><li>End-to-end versus network assisted approaches</li><li>Fairness</li><li>Fixed allocation (TDM, FDM, WDM) versus dynamic allocation</li><li>Need for resource allocation</li><li>Principles of congestion control</li></ul><li>Mobility</li><ul><li>802.11 networks</li><li>Issues in supporting mobile nodes (home agents)</li><li>Principles of cellular networks</li></ul><li>Social Networking</li><ul><li>Example social network platforms</li><li>Social network analysis</li><li>Social networks overview</li><li>Structure of social network graphs</li></ul></ul><li>Operating Systems </li><ul><li>Overview of Operating Systems</li><ul><li>Design issues (efficiency, robustness, flexibility, portability, security, compatibility)</li><li>Functionality of a typical operating system</li><li>Influences of security, networking, multimedia, windowing systems</li><li>Mechanisms to support  client-server models, hand-held devices</li><li>Role and purpose of the operating system</li></ul><li>Operating System Principles</li><ul><li>Abstractions, processes, and resources</li><li>Concept of user/system state and protection, transition to kernel mode</li><li>Concepts of application program interfaces (APIs)</li><li>Device organization</li><li>Interrupts: methods and implementations</li><li>Structuring methods (monolithic, layered, modular, micro-kernel models)</li><li>The evolution of hardware/software techniques and application needs</li></ul><li>Concurrency</li><ul><li>Dispatching and context switching</li><li>Implementing synchronization primitives</li><li>Managing atomic access to OS objects</li><li>Multiprocessor issues (spin-locks, reentrancy) (cross-reference SF/Parallelism)</li><li>States and state diagrams (cross-reference SF/State and State Machines)</li><li>Structures (ready list, process control blocks, and so forth)</li><li>The role of interrupts</li></ul><li>Scheduling and Dispatch</li><ul><li>Deadlines and real-time issues</li><li>Preemptive and non-preemptive scheduling (cross-reference SF/Resource Allocation and Scheduling, PD/Parallel Performance)</li><li>Processes and threads (cross-reference SF/Computational paradigms)</li><li>Schedulers and policies (cross-reference SF/Resource Allocation and Scheduling, PD/Parallel Performance)</li></ul><li>Memory Management</li><ul><li>Caching (cross-reference AR/Memory System Organization and Architecture)</li><li>Review of physical memory and memory management hardware</li><li>Working sets and thrashing</li></ul><li>Security and Protection</li><ul><li>Backups</li><li>Overview of system security</li><li>Policy/mechanism separation</li><li>Protection, access control, and authentication</li><li>Security methods and devices</li></ul><li>Virtual Machines</li><ul><li>Cost of virtualization</li><li>Hypervisors</li><li>Paging and virtual memory</li><li>Portable virtualization; emulation vs. isolation</li><li>Types of virtualization (including Hardware/Software, OS, Server, Service, Network)</li><li>Virtual file systems</li></ul><li>Device Management</li><ul><li>Abstracting device differences</li><li>Buffering strategies</li><li>Characteristics of serial and parallel devices</li><li>Direct memory access</li><li>Recovery from failures</li></ul><li>File Systems</li><ul><li>Directories: contents and structure</li><li>File systems: partitioning, mount/unmount, virtual file systems</li><li>Files: data, metadata, operations, organization, buffering, sequential, nonsequential</li><li>Journaling and log-structured file systems</li><li>Memory-mapped files</li><li>Naming, searching, access, backups</li><li>Special-purpose file systems</li><li>Standard implementation techniques</li></ul><li>Real Time and Embedded Systems</li><ul><li>Failures, risks, and recovery</li><li>Memory/disk management requirements in a real-time environment</li><li>Process and task scheduling</li><li>Special concerns in real-time systems</li></ul><li>Fault Tolerance</li><ul><li>Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of these techniques for the OS's own services</li><li>Fundamental concepts: reliable and available systems (cross-reference SF/Reliability through Redundancy)</li><li>Methods used to implement fault tolerance</li><li>Spatial and temporal redundancy (cross-reference SF/Reliability through Redundancy)</li></ul><li>System Performance Evaluation</li><ul><li>Evaluation models: deterministic, analytic, simulation, or implementation-specific</li><li>How to collect evaluation data (profiling and tracing mechanisms)</li><li>Systems performance policies, e.g., caching, paging, scheduling, memory management, and security</li><li>What is to be evaluated (cross-reference SF/Performance/Figures of performance merit)</li><li>Why system performance needs to be evaluated (cross-reference SF/Performance/Figures of performance merit)</li></ul></ul><li>Platform-Based Development </li><ul><li>Introduction</li><ul><li>Overview of Platform Languages (e.g., Objective C, HTML5)</li><li>Overview of platforms (e.g., Web, Mobile, Game, Industrial)</li><li>Programming under platform constraints</li><li>Programming via platform-specific APIs</li></ul><li>Web Platforms</li><ul><li>Software as a Service (SaaS)</li><li>Web platform constraints</li><li>Web programming languages (e.g., HTML5, Java Script, PHP, CSS)</li><li>Web standards</li></ul><li>Mobile Platforms</li><ul><li>Challenges with mobility and wireless communication</li><li>Emerging technologies</li><li>Location-aware applications</li><li>Mobile platform constraints</li><li>Mobile programming languages</li><li>Performance / power tradeoffs</li></ul><li>Industrial Platforms</li><ul><li>Domain-specific languages</li><li>Industrial platform constraints</li><li>Robotic software and its architecture</li><li>Types of Industrial Platforms (e.g., Mathematic, Robotic, Industrial Control)</li></ul><li>Game Platforms</li><ul><li>Game platform constraints</li><li>Game platform languages (e.g., C++, Java, Lua, Python)</li><li>Types of game platforms (e.g., XBox, Wii, PlayStation)</li></ul></ul><li>Parallel and Distributed Computing </li><ul><li>Parallelism Fundamentals</li><ul><li>Goals of parallelism (e.g., throughput) versus concurrency (e.g., controlling access to shared resources)</li><li>Multiple simultaneous computations</li><li>Parallelism, communication, and coordination</li><ul><li>Need for synchronization</li><li>Programming constructs for coordinating multiple simultaneous computations</li></ul><li>Programming errors not found in sequential programming</li><ul><li>Data races (simultaneous read/write or write/write of shared state)</li><li>Higher-level races (interleavings violating program intention, undesired non-determinism)</li><li>Lack of liveness/progress (deadlock, starvation)</li></ul></ul><li>Parallel Decomposition</li><ul><li>Actors and reactive processes (e.g., request handlers)</li><li>Basic knowledge of parallel decomposition concepts (cross-reference SF/System Support for Parallelism)</li><li>Data-parallel decomposition</li><ul><li>Strategies such as SIMD and MapReduce</li></ul><li>Independence and partitioning</li><li>Need for communication and coordination/synchronization</li><li>Task-based decomposition</li><ul><li>Implementation strategies such as threads</li></ul></ul><li>Communication and Coordination</li><ul><li>Atomicity</li><ul><li>Granularity of atomic accesses and updates, and the use of constructs such as critical sections or transactions to describe them</li><li>Mutual Exclusion using locks, semaphores, monitors, or related constructs</li><ul><li>Potential for liveness failures and deadlock (causes, conditions, prevention)</li></ul><li>Specifying and testing atomicity and safety requirements</li></ul><li>Composition</li><ul><li>Composing larger granularity atomic actions using synchronization</li><li>Transactions, including optimistic and conservative approaches</li></ul><li>Conditional actions</li><ul><li>Conditional waiting (e.g., using condition variables)</li></ul><li>Consensus</li><ul><li>(Cyclic) barriers, counters, or related constructs</li></ul><li>Consistency, and its role in programming language guarantees for data-race-free programs</li><li>Message passing</li><ul><li>Blocking versus non-blocking styles for sending and receiving messages</li><li>Message buffering (cross-reference PF/Fundamental Data Structures/Queues)</li><li>Point-to-point versus multicast (or event-based) messages</li></ul><li>Shared Memory</li></ul><li>Parallel Algorithms, Analysis, and Programming</li><ul><li>Critical paths, work and span, and the relation to Amdahl's law (cross-reference SF/Performance)</li><li>Examples of non-scalable parallel algorithms</li><li>Naturally (embarrassingly) parallel algorithms</li><li>Parallel algorithmic patterns (divide-and-conquer, map and reduce, master-workers, others)</li><ul><li>Specific algorithms (e.g., parallel MergeSort)</li></ul><li>Parallel graph algorithms (e.g., parallel shortest path, parallel spanning tree) (cross-reference AL/Algorithmic Strategies/Divide-and-conquer)</li><li>Parallel matrix computations</li><li>Producer-consumer and pipelined algorithms</li><li>Speed-up and scalability</li></ul><li>Parallel Architecture</li><li>Parallel Performance</li><ul><li>Data management</li><ul><li>Cache effects (e.g., false sharing)</li><li>Maintaining spatial locality</li><li>Non-uniform communication costs due to proximity (cross-reference SF/Proximity)</li></ul><li>Evaluating communication overhead</li><li>Load balancing</li><li>Performance measurement</li><li>Power usage and management</li><li>Scheduling and contention (cross-reference OS/Scheduling and Dispatch)</li></ul><li>Distributed Systems</li><ul><li>Core distributed algorithms</li><ul><li>Election, discovery</li></ul><li>Distributed message sending</li><ul><li>Buffering, retrying, and dropping messages</li><li>Data conversion and transmission</li><li>Message sequencing</li><li>Sockets</li></ul><li>Distributed service design</li><ul><li>Reactive (IO-triggered) and multithreaded designs</li><li>Session (connection-based) designs</li><li>Stateful versus stateless protocols and services</li></ul><li>Distributed system design tradeoffs</li><ul><li>Consistency, availability, partition tolerance</li><li>Latency versus throughput</li></ul><li>Faults (cross-reference OS/Fault Tolerance)</li><ul><li>Impact on system-wide guarantees (e.g., availability)</li><li>Network-based (including partitions) and node-based failures</li></ul></ul><li>Cloud Computing</li><ul><li>Cloud services</li><ul><li>Cost management</li><li>Infrastructure as a service</li><ul><li>Elasticity of resources</li><li>Platform APIs</li></ul><li>Security</li><li>Software as a service</li></ul><li>Cloud-based data storage</li><ul><li>Data partitioning</li><li>Data synchronization</li><li>Distributed file systems (cross-reference IM/Distributed Databases)</li><li>Replication</li><li>Shared access to weakly consistent data stores</li></ul><li>Internet-Scale computing</li><ul><li>Clusters, grids, and meshes</li><li>Data access</li><li>Task partitioning (cross-reference PD/Parallel Algorithms, Analysis, and Programming)</li></ul><li>Virtualization (cross-reference SF/Virtualization and Isolation and OS/Virtual Machines)</li><ul><li>Migration of processes</li><li>Shared resource management</li></ul></ul><li>Formal Models and Semantics</li><ul><li>Algorithmic correctness criteria including linearizability</li><li>Formal models of computational dependencies</li><li>Formal models of parallel computation, including the Parallel Random Access Machine (PRAM) and alternatives such as Bulk Synchronous Parallel (BSP)</li><li>Formal models of processes and message passing, including algebras such as Communicating Sequential Processes (CSP) and pi-calculus</li><li>Models of (relaxed) shared memory consistency and their relation to programming language specifications</li><li>Models of algorithmic progress, including non-blocking guarantees and fairness</li><li>Techniques for specifying and checking correctness properties such as atomicity and freedom from data races</li></ul></ul><li>Programming Languages </li><ul><li>Object-Oriented Programming</li><ul><li>Definition of classes: fields, methods, and constructors</li><li>Dynamic dispatch: definition of method-call</li><li>Object-oriented design</li><ul><li>Class-hierarchy design for modeling</li><li>Decomposition into objects carrying state and having behavior</li></ul><li>Object-oriented idioms for encapsulation</li><ul><li>Abstract base classes</li><li>Interfaces revealing only method signatures</li><li>Privacy and visibility of class members</li></ul><li>Subclasses, inheritance, and method overriding</li><li>Subtyping (cross-reference PL/Type Systems)</li><ul><li>Notion of behavioral replacement: subtypes acting like supertypes</li><li>Relationship between subtyping and inheritance</li><li>Subtype polymorphism; implicit upcasts in typed languages</li></ul><li>Using collection classes, iterators, and other common library components</li></ul><li>Functional Programming</li><ul><li>Defining higher-order operations on aggregates, especially map, reduce/fold, and filter</li><li>Effect-free programming</li><ul><li>Data can be freely aliased or copied without introducing unintended effects from mutation</li><li>Function calls have no side effects, facilitating compositional reasoning</li><li>Variables are immutable, preventing unexpected changes to program data by other code</li></ul><li>First-class functions (taking, returning, and storing functions)</li><li>Function closures (functions using variables in the enclosing lexical environment)</li><ul><li>Basic meaning and definition -- creating closures at run-time by capturing the environment</li><li>Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments</li><li>Currying and partial application</li><li>Using a closure to encapsulate data in its environment</li></ul><li>Processing structured data (e.g., trees) via functions with cases for each data variant</li><ul><li>Associated language constructs such as discriminated unions and pattern-matching over them</li><li>Functions defined over compound data in terms of functions applied to the constituent pieces</li></ul></ul><li>Event-Driven and Reactive Programming</li><ul><li>Canonical uses such as GUIs, mobile devices, robots, servers</li><li>Events and event handlers</li><li>Externally-generated events and program-generated events</li><li>Separation of model, view, and controller</li><li>Using a reactive framework</li><ul><li>Defining event handlers/listeners</li><li>Main event loop not under event-handler-writer's control</li></ul></ul><li>Basic Type Systems</li><ul><li>A type as a set of values together with a set of operations</li><ul><li>Compound types built from other types (e.g., records, unions, arrays, lists, functions, references)</li><li>Primitive types (e.g., numbers, Booleans)</li></ul><li>Association of types to variables, arguments, results, and fields</li><li>Avoid misuse of code vs. allow more code reuse</li><li>Complementary benefits of static and dynamic typing</li><ul><li>Errors early vs. errors late/avoided</li></ul><li>Detect incomplete programs vs. allow incomplete programs to run</li><li>Enforce invariants during code development and code maintenance vs. postpone typing decisions while prototyping and conveniently allow flexible coding patterns such as heterogeneous collections</li><li>Generic types (parametric polymorphism)</li><ul><li>Comparison with ad hoc polymorphism (overloading) and subtype polymorphism</li><li>Definition</li><li>Use for generic libraries such as collections</li></ul><li>Goals and limitations of static typing</li><ul><li>Eliminating some classes of errors without running the program</li><li>Undecidability means static analysis must conservatively approximate program behavior</li></ul><li>Type safety and errors caused by using values inconsistently given their intended types</li></ul><li>Program Representation</li><ul><li>Abstract syntax trees; contrast with concrete syntax</li><li>Data structures to represent code for execution, translation, or transmission</li><li>Programs that take (other) programs as input such as interpreters, compilers, type-checkers, documentation generators</li></ul><li>Language Translation and Execution</li><ul><li>Interpretation vs. compilation to native code vs. compilation to portable intermediate representation</li><li>Language translation pipeline: parsing, optional type-checking, translation, linking, execution</li><ul><li>Alternatives like dynamic loading and dynamic (or 'just-in-time') code generation</li><li>Execution as native code or within a virtual machine</li></ul><li>Memory management</li><ul><li>Automated memory management: garbage collection as an automated technique using the notion of reachability</li><li>Manual memory management: allocating, de-allocating, and reusing heap memory</li></ul><li>Run-time layout of memory: call-stack, heap, static data</li><ul><li>Implementing loops, recursion, and tail calls</li></ul><li>Run-time representation of core language constructs such as objects (method tables) and first-class functions (closures)</li></ul><li>Syntax Analysis</li><ul><li>Generating scanners and parsers from declarative specifications</li><li>Parsing strategies including top-down (e.g., recursive descent, Earley parsing, or LL) and bottom-up (e.g., backtracking or LR) techniques; role of context-free grammars</li><li>Scanning (lexical analysis) using regular expressions</li></ul><li>Compiler Semantic Analysis</li><ul><li>Declarative specifications such as attribute grammars</li><li>High-level program representations such as abstract syntax trees</li><li>Scope and binding resolution</li><li>Type checking</li></ul><li>Code Generation</li><ul><li>Instruction scheduling</li><li>Instruction selection</li><li>Peephole optimization</li><li>Procedure calls and method dispatching</li><li>Register allocation</li><li>Separate compilation; linking</li></ul><li>Runtime Systems</li><ul><li>Data layout for objects and activation records</li><li>Dynamic memory management approaches and techniques: malloc/free, garbage collection (mark-sweep, copying, reference counting), regions (also known as arenas or zones)</li><li>Just-in-time compilation and dynamic recompilation</li><li>Other common features of virtual machines, such as class loading, threads, and security.</li></ul><li>Static Analysis</li><ul><li>Flow-insensitive analyses, such as type-checking and scalable pointer and alias analyses</li><li>Flow-sensitive analyses, such as forward and backward dataflow analyses</li><li>Path-sensitive analyses, such as software model checking</li><li>Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and static single assignment</li><li>Role of static analysis in (partial) verification and bug-finding</li><li>Role of static analysis in program optimization</li><li>Tools and frameworks for defining analyses</li><li>Undecidability and consequences for program analysis</li></ul><li>Advanced Programming Constructs</li><ul><li>Control Abstractions: Exception Handling, Continuations, Monads</li><li>Dynamic code evaluation ('eval')</li><li>Language support for checking assertions, invariants, and pre/post-conditions</li><li>Lazy evaluation and infinite streams</li><li>Metaprogramming: Macros, Generative programming, Model-based development</li><li>Module systems</li><li>Object-oriented abstractions: Multiple inheritance, Mixins, Traits, Multimethods</li><li>String manipulation via pattern-matching (regular expressions)</li></ul><li>Concurrency and Parallelism</li><ul><li>Actor models</li><li>Constructs for thread-shared variables and shared-memory synchronization</li><li>Effect of memory-consistency models on language semantics and correct code generation</li><li>Futures</li><li>Language support for data parallelism</li><li>Models for passing messages between sequential processes</li></ul><li>Type Systems</li><ul><li>Compositional type constructors, such as product types (for aggregates), sum types (for unions), function types, quantified types, and recursive types</li><li>Static overloading</li><li>Type checking</li><li>Type inference</li><li>Type safety as preservation plus progress</li></ul><li>Formal Semantics</li><ul><li>Approaches to semantics: Operational, Denotational, Axiomatic</li><li>Formal definitions and proofs for type systems (cross-reference PL/Type Systems)</li><li>Lambda Calculus</li><li>Parametricity (cross-reference PL/Type Systems)</li><li>Proofs by induction over language semantics</li><li>Syntax vs. semantics</li><li>Using formal semantics for systems modeling</li></ul><li>Language Pragmatics</li><ul><li>Defining control and iteration constructs</li><li>Eager vs. delayed evaluation</li><li>Evaluation order, precedence, and associativity</li><li>External calls and system libraries</li><li>Principles of language design such as orthogonality</li></ul><li>Logic Programming</li><ul><li>Backtracking and search</li><li>Clausal representation of data structures and algorithms</li><li>Cuts</li><li>Unification</li></ul></ul><li>Software Development Fundamentals </li><ul><li>Algorithms and Design</li><ul><li>Fundamental design concepts and principles</li><ul><li>Abstraction</li><li>Encapsulation and information hiding</li><li>Program decomposition</li><li>Separation of behavior and implementation</li></ul><li>Problem-solving strategies</li><ul><li>Divide-and-conquer strategies</li><li>Iterative and recursive mathematical functions</li><li>Iterative and recursive traversal of data structures</li></ul><li>The concept and properties of algorithms</li><ul><li>Informal comparison of algorithm efficiency (e.g., operation counts)</li></ul><li>The role of algorithms in the problem-solving process</li></ul><li>Fundamental Programming Concepts</li><ul><li>Basic syntax and semantics of a higher-level language</li><li>Conditional and iterative control structures</li><li>Expressions and assignments</li><li>Functions and parameter passing</li><li>Simple I/including file I/O</li><li>The concept of recursion</li><li>Variables and primitive data types (e.g., numbers, characters, Booleans)</li></ul><li>Fundamental Data Structures</li><ul><li>Abstract data types and their implementation</li><ul><li>Maps</li><li>Priority queues Sets</li><li>Queues</li><li>Stacks</li></ul><li>Arrays</li><li>Linked lists</li><li>Records/structs (heterogeneous aggregates)</li><li>References and aliasing</li><li>Strategies for choosing the appropriate data structure</li><li>Strings and string processing</li></ul><li>Development Methods</li><ul><li>Debugging strategies</li><li>Documentation and program style</li><li>Modern programming environments</li><ul><li>Code search</li><li>Programming using library components and their APIs</li></ul><li>Program comprehension</li><li>Program correctness</li><ul><li>Code reviews</li><li>Defensive programming (e.g. secure coding, exception handling)</li><li>Testing fundamentals and test-case generation</li><li>The concept of a specification</li><li>The role and the use of contracts, including pre- and post-conditions</li><li>Types of errors (syntax, logic, run-time)</li><li>Unit testing</li></ul><li>Simple refactoring</li></ul></ul><li>Software Engineering </li><ul><li>Software Processes</li><ul><li>Evaluation of software process models</li><li>Introduction to software process models (e.g., waterfall, incremental, agile)</li><ul><li>Activities within software lifecycles</li></ul><li>Process improvement</li><li>Programming in the large vs. individual programming</li><li>Software process capability maturity models</li><li>Software process measurements</li><li>Software quality concepts</li><li>Systems level considerations, i.e., the interaction of software with its intended environment (cross-reference IAS/Secure Software Engineering)</li></ul><li>Software Project Management</li><ul><li>Effort Estimation (at the personal level)</li><li>Project management</li><ul><li>Cost/benefit analysis</li><li>Project management tools</li><li>Scheduling and tracking</li></ul><li>Risk</li><ul><li>Risk analysis and evaluation</li><li>Risk identification and management</li><li>Risk planning</li><li>Risk tolerance (e.g., risk-adverse, risk-neutral, risk-seeking)</li></ul><li>Risk (cross reference IAS/Secure Software Engineering)</li><ul><li>Risk categories including security, safety, market, financial, technology, people, quality, structure and process</li><li>The role of risk in the lifecycle</li></ul><li>Software measurement and estimation techniques</li><li>Software quality assurance and the role of measurements</li><li>System-wide approach to risk including hazards associated with tools</li><li>Team management</li><ul><li>Individual and team performance assessment</li><li>Role identification and assignment</li><li>Team organization and decision-making</li></ul><li>Team participation</li><ul><li>Risks associated with virtual teams (communication, perception, structure)</li><li>Roles and responsibilities in a software team</li><li>Team conflict resolution</li><li>Team processes including responsibilities for tasks, meeting structure, and work schedule</li></ul></ul><li>Tools and Environments</li><ul><li>Programming environments that automate parts of program construction processes (e.g., automated builds)</li><ul><li>Continuous integration</li></ul><li>Release management</li><li>Requirements analysis and design modeling tools</li><li>Software configuration management and version control</li><li>Testing tools including static and dynamic analysis tools</li><li>Tool integration concepts and mechanisms</li></ul><li>Requirements Engineering</li><ul><li>Acceptability of certainty / uncertainty considerations regarding software / system behavior</li><li>Basic concepts of formal requirements specification</li><li>Describing functional requirements using, for example, use cases or users stories</li><li>Describing system data using, for example, class diagrams or entity-relationship diagrams</li><li>Evaluation and use of requirements specifications</li><li>Non-functional requirements and their relationship to software quality (cross-reference IAS/Secure Software Engineering)</li><li>Properties of requirements including consistency, validity, completeness, and feasibility</li><li>Prototyping</li><li>Requirements analysis modeling techniques</li><li>Requirements specification</li><li>Requirements tracing</li><li>Requirements validation</li><li>Software requirements elicitation</li></ul><li>Software Design</li><ul><li>Application frameworks</li><li>Design Paradigms such as structured design (top-down functional decomposition), object-oriented analysis and design, event driven design, component-level design, data-structured centered, aspect oriented, function oriented, service oriented</li><li>Design patterns</li><li>External design qualities, and models for them: functionality, reliability, performance and efficiency, usability, maintainability, portability</li><li>Internal design qualities, and models for them: efficiency and performance, redundancy and fault tolerance, traceability of requirements</li><li>Measurement and analysis of design quality</li><li>Middleware: the object-oriented paradigm within middleware, object request brokers and marshalling, transaction processing monitors, workflow systems</li><li>Principles of secure design and coding (cross-reference IAS/Principles of Secure Design)</li><ul><li>Principle of fail-safe defaults</li><li>Principle of least privilege</li><li>Principle of psychological acceptability</li></ul><li>Refactoring designs using design patterns</li><li>Relationships between requirements and designs: transformation of models, design of contracts, invariants</li><li>Software architecture concepts and standard architectures (e.g. client-server, n-layer, transform centered, pipes-and-filters)</li><li>Structural and behavioral models of software designs</li><li>System design principles: levels of abstraction (architectural design and detailed design), separation of concerns, information hiding, coupling and cohesion, re-use of standard structures</li><li>The use of components in design: component selection, design, adaptation and assembly of components, components and patterns, components and objects (for example, building a GUI using a standard widget set)</li><li>Tradeoffs between different aspects of quality</li></ul><li>Software Construction</li><ul><li>Coding practices: techniques, idioms/patterns, mechanisms for building quality programs (cross-reference IAS/Defensive Programming; SDF/Development Methods)</li><ul><li>Defensive coding practices</li><li>Secure coding practices</li><li>Using exception handling mechanisms to make programs more robust, fault-tolerant</li></ul><li>Coding standards</li><li>Development context: 'green field' vs. existing code base</li><ul><li>Change actualization</li><li>Change impact analysis</li></ul><li>Integration strategies</li><li>Potential security problems in programs</li><ul><li>Assuming success and correctness</li><li>Buffer and other types of overflows Race conditions</li><li>Checking input</li><li>Improper initialization, including choice of privileges</li><li>Validating assumptions</li></ul></ul><li>Software Verification and Validation</li><ul><li>Defect tracking</li><li>Fault estimation and testing termination including defect seeding</li><li>Fault logging, fault tracking and technical support for such activities</li><li>Inspections, reviews, audits</li><li>Limitations of testing in particular domains, such as parallel or safety-critical systems</li><li>Object-oriented testing; systems testing</li><li>Static approaches and dynamic approaches to verification</li><li>Test-driven development</li><li>Testing fundamentals (cross-reference SDF/Development Methods)</li><ul><li>Black-box and white-box testing techniques</li><li>Regression testing and test automation</li><li>Test plan creation and test case generation</li><li>Unit, integration, validation, and system testing</li></ul><li>Testing types, including human computer interface, usability, reliability, security, conformance to specification (cross-reference IAS/Secure Software Engineering)</li><li>Validation planning; documentation for validation</li><li>Verification and validation concepts</li><li>Verification and validation of non-code artifacts (documentation, help files, training materials)</li></ul><li>Software Evolution</li><ul><li>Characteristics of maintainable software</li><li>Reengineering systems</li><li>Software development in the context of large, pre-existing code bases</li><ul><li>Concerns and concern location</li><li>Refactoring</li><li>Software change</li></ul><li>Software evolution</li><li>Software reuse</li><ul><li>Code segments</li><li>Components</li><li>Libraries and frameworks</li><li>Product lines</li></ul></ul><li>Software Reliability</li><ul><li>Fault lifecycle concepts and techniques</li><li>Measurement-based analysis of software reliability</li><li>Software fault tolerance techniques and models</li><li>Software reliability engineering concepts</li><li>Software reliability engineering practices</li><li>Software reliability models</li><li>Software reliability, system reliability and failure behavior (cross-reference SF/Reliability Through Redundancy)</li></ul><li>Formal Methods</li><ul><li>Formal approaches to software modeling and analysis</li><ul><li>Model checkers</li><li>Model finders</li></ul><li>Program assertion languages and analysis approaches (including languages for writing and analyzing pre-and post-conditions, such as OCL, JML)</li><li>Role of formal specification and analysis techniques in the software development cycle</li><li>Tools in support of formal methods</li></ul></ul><li>Systems Fundamentals </li><ul><li>Computational Paradigms</li><ul><li>Application-level sequential processing: single thread</li><li>Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections; Datapath + Control + Memory)</li><li>Basic concept of pipelining, overlapped processing stages</li><li>Basic concept of scaling: going faster vs. handling larger problems</li><li>Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms</li><li>Simple application-level parallel processing: request level (web services/client-server/distributed), single thread per server, multiple threads with multiple servers</li></ul><li>Cross-Layer Communications</li><ul><li>Application-Virtual Machine Interaction</li><li>Distinction between Application and OS services, Remote Procedure Call</li><li>Programming abstractions, interfaces, use of libraries</li><li>Reliability</li></ul><li>State and State Machines</li><ul><li>Clocks, State, Sequencing</li><li>Combinational Logic, Sequential Logic, Registers, Memories</li><li>Computers and Network Protocols as examples of state machines</li><li>Digital vs. Analog/Discrete vs. Continuous Systems</li><li>Simple logic gates, logical expressions, Boolean logic simplification</li></ul><li>Parallelism</li><ul><li>Client-Server/Web Services, Thread (Fork-Join), Pipelining</li><li>Multicore architectures and hardware support for synchronization</li><li>Parallel programming vs. concurrent programming</li><li>Request parallelism vs. Task parallelism</li><li>Sequential vs. parallel processing</li></ul><li>Evaluation</li><ul><li>Amdahl's Law: the part of the computation that cannot be sped up limits the effect of the parts that can</li><li>CPI (Cycles per Instruction) equation as tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations.</li><li>Performance figures of merit</li><li>Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit</li></ul><li>Resource Allocation and Scheduling</li><ul><li>Advantages of fair scheduling, preemptive scheduling</li><li>Kinds of resources (e.g., processor share, memory, disk, net bandwidth)</li><li>Kinds of scheduling (e.g., first-come, priority)</li></ul><li>Proximity</li><ul><li>Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture</li><li>Caches and the effects of spatial and temporal locality on performance in processors and systems</li><li>Introduction into the processor memory hierarchy and the formula for average memory access time</li><li>Latencies in computer systems: memory vs. disk latencies vs. across the network memory</li><li>Speed of light and computers (one foot per nanosecond vs. one GHz clocks)</li></ul><li>Virtualization and Isolation</li><ul><li>Levels of indirection, illustrated by virtual memory for managing physical memory resources</li><li>Methods for implementing virtual memory and virtual machines</li><li>Rationale for protection and predictable performance</li></ul><li>Reliability through Redundancy</li><ul><li>Distinction between bugs and faults</li><li>Duplication/mirroring/replicas</li><li>Other approaches to fault tolerance and availability</li><li>Redundancy through check and retry</li><li>Redundancy through redundant encoding (error correcting codes, CRC, FEC)</li></ul><li>Quantitative Evaluation</li><ul><li>Analysis of slow and fast paths of a system</li><li>Analytical tools to guide quantitative evaluation</li><li>Events on their effect on performance (e.g., instruction stalls, cache misses, page faults)</li><li>Microbenchmarking pitfalls</li><li>Order of magnitude analysis (Big-Oh notation)</li><li>Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation</li></ul></ul><li>Social Issues and Professional Practice </li><ul><li>Social Context</li><ul><li>Accessibility issues, including legal requirements</li><li>Context-aware computing (cross-reference HCI/Design for non-mouse interfaces/ ubiquitous and context-aware)</li><li>Growth and control of the Internet (cross-reference NC/Introduction/organization of the Internet)</li><li>Impact of social media on individualism, collectivism and culture.</li><li>Often referred to as the digital divide, differences in access to digital technology resources and its resulting ramifications for gender, class, ethnicity, geography, and/or underdeveloped countries.</li><li>Social implications of computing in a networked world (cross-reference HCI/Foundations/social models; IAS/Fundamental Concepts/social issues)</li></ul><li>Analytical Tools</li><ul><li>Ethical argumentation</li><li>Ethical theories and decision-making</li><li>Moral assumptions and values</li></ul><li>Professional Ethics</li><ul><li>Acceptable use policies for computing in the workplace</li><li>Accountability, responsibility and liability (e.g. software correctness, reliability and safety, as well as ethical confidentiality of cybersecurity professionals)</li><li>Community values and the laws by which we live</li><li>Dealing with harassment and discrimination</li><li>Ergonomics and healthy computing environments</li><li>Ethical dissent and whistle-blowing</li><li>Forms of professional credentialing</li><li>Keeping up-to-date as a computing professional in terms of familiarity, tools, skills, legal and professional framework as well as the ability to self-assess and progress in the computing field</li><li>Maintaining awareness of consequences</li><li>Professional certification, codes of ethics, conduct, and practice, such as the ACM/IEEE-CS, SE, AITP, IFIP and international societies (cross-reference IAS/Fundamental Concepts/ethical issues)</li><li>The nature of professionalism including care, attention and discipline, fiduciary responsibility, and mentoring</li><li>The relationship between regional culture and ethical dilemmas</li><li>The role of the computing professional in public policy</li><li>Time to market and cost considerations versus quality professional standards</li></ul><li>Intellectual Property</li><ul><li>Copyrights, patents, trade secrets, trademarks</li><li>Digital rights management</li><li>Foundations of the open source movement</li><li>Intangible digital intellectual property (IDIP)</li><li>Intellectual property rights (cross-reference IM/Information Storage and Retrieval/intellectual property and protection)</li><li>Legal foundations for intellectual property protection</li><li>Philosophical foundations of intellectual property</li><li>Plagiarism</li><li>Software piracy</li></ul><li>Privacy and Civil Liberties</li><ul><li>Civil liberties and cultural differences</li><li>Freedom of expression and its limitations</li><li>Legal foundations of privacy protection</li><li>Philosophical foundations of privacy rights (cross-reference IS/Fundamental Issues/philosophical issues)</li><li>Privacy implications of widespread data collection for transactional databases, data warehouses, surveillance systems, and cloud computing (cross-reference IM/Database Systems/data independence; IM/Data Mining/data cleaning)</li><li>Privacy legislation in areas of practice</li><li>Ramifications of differential privacy</li><li>Technology-based solutions for privacy protection (cross-reference IAS/Threats and Attacks/attacks on privacy and anonymity)</li></ul><li>Professional Communication</li><ul><li>Communicating professionally with stakeholders</li><li>Dealing with cross-cultural environments (cross-reference HCI/User-Centered Design and Testing/cross-cultural evaluation)</li><li>Dynamics of oral, written, and electronic team and group communication (cross-reference HCI/Collaboration and Communication/group communication; SE/Project Management/team participation)</li><li>Reading, understanding and summarizing technical material, including source code and documentation</li><li>Tradeoffs of competing risks in software projects, such as technology, structure/process, quality, people, market and financial (cross-reference SE/Software Project Management/Risk)</li><li>Utilizing collaboration tools (cross-reference HCI/Collaboration and Communication/online communities; IS/Agents/collaborative agents)</li><li>Writing effective technical documentation and materials</li></ul><li>Sustainability</li><ul><li>Being a sustainable practitioner by taking into consideration cultural and environmental impacts of implementation decisions (e.g. organizational policies, economic viability, and resource consumption).</li><li>Environmental impacts of design choices in specific areas such as algorithms, operating systems, networks, databases, or human-computer interaction (cross-reference SE/Software Evaluation/software evolution; HCI/Design-Oriented HCI/sustainability)</li><li>Explore global social and environmental impacts of computer use and disposal (e-waste)</li><li>Guidelines for sustainable design standards</li><li>Pervasive computing; information processing integrated into everyday objects and activities, such as smart energy systems, social networking and feedback systems to promote sustainable behavior, transportation, environmental monitoring, citizen science and activism.</li><li>Research on applications of computing to environmental issues, such as energy, pollution, resource usage, recycling and reuse, food management, farming and others.</li><li>Systemic effects of complex computer-mediated phenomena (e.g. telecommuting or web shopping)</li><li>The interdependence of the sustainability of software systems with social systems, including the knowledge and skills of its users, organizational processes and policies, and its societal context (e.g., market forces, government policies).</li></ul><li>History</li><ul><li>History of computer hardware, software, networking (cross-reference AR/Digital logic and digital systems/ history of computer architecture)</li><li>History of the Internet</li><li>Pioneers of computing</li><li>Prehistory'the world before 1946</li></ul><li>Economies of Computing</li><ul><li>Consequences of globalization for the computer science profession</li><li>Cost estimates versus actual costs in relation to total costs</li><li>Cost/benefit analysis of jobs with considerations to manufacturing, hardware, software, and engineering implications</li><li>Differences in access to computing resources and the possible effects thereof</li><li>Effect of skilled labor supply and demand on the quality of computing products</li><li>Entrepreneurship: prospects and pitfalls</li><li>Monopolies and their economic implications</li><li>Network effect or demand-side economies of scale</li><li>Pricing strategies in the computing domain</li><li>The phenomenon of outsourcing and off-shoring software development; impacts on employment and on economics</li><li>Use of engineering economics in dealing with finances</li></ul><li>Security Policies, Laws and Computer Crimes</li><ul><li>Crime prevention strategies</li><li>Effects of malware, such as viruses, worms and Trojan horses</li><li>Examples of computer crimes and legal redress for computer criminals (cross-reference IAS/Digital Forensics/rules of evidence)</li><li>Issues surrounding the misuse of access and breaches in security</li><li>Motivations and ramifications of cyber terrorism and criminal hacking, 'cracking'</li><li>Security policies (cross-reference IAS/Security Policy and Governance/policies)</li><li>Social engineering, identity theft and recovery (cross-reference HCI/Human Factors and Security/trust, privacy and deception)</li></ul></ul></ul>

    </ul>
	
	

    <script>
        const searchInput = document.getElementById('search');
        const treeview = document.getElementById('treeview');
        const nodes = Array.from(document.querySelectorAll('#treeview li'));

        searchInput.addEventListener('input', () => {
            const searchText = searchInput.value.toLowerCase();

            nodes.forEach(node => {
                const text = node.textContent.toLowerCase();
                const isMatch = text.includes(searchText);
                node.style.display = isMatch ? 'block' : 'none';
            });
        });

        nodes.forEach(node => {
            node.addEventListener('click', () => {
                const ul = node.querySelector('ul');
                if (ul) {
                    ul.style.display = ul.style.display === 'none' ? 'block' : 'none';
                }
            });
        });
    </script>
</body>
</html>
